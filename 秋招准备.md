# 面试准备

[TOC]

## CPP

#### 1. C与C++的区别(面向对象的特点)，面向对象的了解

C和C++的区别主要体现在C是面向过程的，C++是面向对象的。

面向对象带来了诸多优势，主要体现在它的四大特性上面。

1. 抽象，抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。
2. 封装，封装就是把方法和数据包围起来，对数据的访问只能通过特定的接口，不能直接操作数据本身。
3. 继承，提高了开发效率，利用继承实现各种设计模式。
4. 多态，利用面向对象可以实现动态的多态，允许不同类的对象对同一函数调用做出不同的响应。

#### 2. CPP 多态的实现，静态多态，动态多态

[参考](https://www.cnblogs.com/weizhixiang/articles/5760286.html)

#### 3. CPP 三种继承方式下的访问控制权限

[参考](<http://blog.csdn.net/casky237/article/details/54766881> )

#### 4. CPP如何唯一确定一个函数的重栽，重栽函数默认初始化方式

C++primer，P217，函数匹配。

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数被称为候选函数，候选函数具备两个特征，一是与被调用的函数同名，二是其声明在调用点可见。第二步是考察本次调用提供的实参，这些新选出的函数被称为可行函数。可行函数也有两个特征，一是其形参数量与本次调用的提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能够转换成形参的类型。

之后便是寻找最佳匹配，从可行函数中选择与本次调用最匹配的函数，在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数，。

如果有且只有一个函数满足以下条件，那么匹配成功，1、该函数每个实参的匹配都不劣于其他可行函数需要的匹配，至少有一个实参的匹配优于其他可行函数的匹配。

如果在检查了所有的实参之后没有任何一个函数脱颖而出，则该调用是错误的。

#### 5. CPP内存分为哪几个部分，堆和栈的区别？哪个是向高地址的？

[参考1](<https://www.zhihu.com/question/26224882>)，[参考2](https://www.zhihu.com/question/36103513?sort=created)
[参考3](<http://chenqx.github.io/2014/09/25/Cpp-Memory-Management/>)

细分的话是六个区域，rodata段、text段、data段、bss段、堆、栈。

* Text Segment
  * .rodata段：存放只读数据，也就是通常所说的常量区，程序结束时由系统释放，多态类的虚函数表也放在这个地方。
  * .text段：存放已经编译的机器代码。
  * 程序加载运行时，.rodata段和.text段通常合并到一个Segment（Text Segment）中，操作系统将这个Segment的页面只读保护起来，防止意外的改写。

* Data Segment
  * .data段: 存放已初始化的全局变量、静态量。
  * .bss段：存放未初始化的全局变量、静态量。
  * 程序加载运行时，.data和.bss在加载时合并到一个Segment（Data Segment）中，这个Segment是可读可写的。

* 栈：由编译器自动分配释放，存放函数参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

* 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

* 在简化的32位Linux/x86进程地址空间模型里，（主线程的）栈空间确实比堆空间的地址要高——它已经占据了用户态地址空间的最高可分配的区域，并且向下（向低地址）增长。借用Gustavo Duarte的[Anatomy of a Program in Memory](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/)里的图：

  ![5.1](image/215522854f166f7b5a537ccfa641c922_hd.png)  

####  6. 动态绑定，静态绑定的定义以及实现

静态绑定为编译时绑定，通过对象调用。

动态绑定即为运行时绑定，通过地址实现，常见例子有一个基类，基类有一个virtual虚函数，派生类中重写了这个函数，现在有一个指向派生的类对象的基类指针或者引用，调用该虚函数时会调用派生类中重写之后的函数。

动态绑定的实现，C++中的动态绑定是通过虚函数实现的，虚函数是通过一张虚函数表实现的，这个表中记录了虚函数的地址，解决继承、覆盖的问题，保证动态绑定石能够根据对象的实际类型调用正确的函数。

#### 7. 只能在栈上构造的对象，只能在堆上构造的对象

只有使用new运算符，对象才会建立在堆上，因此只要禁用new运算符就可以实现类对象只能建立在栈上。

```cpp
class A{
private:
    void* operator new (size_t t){}// 注意函数的第一个参数和返回值都是固定的   
    void operator delete(void* ptr){}// 重载了new就需要重载delete   
public:
    A(){}
    ~A(){}
};
```

类的对象只能建立在堆上，就是不能静态建立类的对象，将析构函数设为私有即可，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。

这样做带来的第一个问题是无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。

这样带来的第二个问题是类的使用会十分不便，为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于单例模式：

```cpp
lass B{
protected:
    B(){}
    ~B(){}
public:
    static B* creat(){
        return new B();
    }
    void destory(){
        delete this;
    }
};
```

#### 8. 虚函数表存放什么内容，存放在哪里，虚函数的调用过程，子类继承基类之后，重写与不重写函数的情况下，虚函数表的内容分别是什么

虚函数表存放的是虚函数指针，该类中有多少虚函数，便有多少个虚函数指针，即虚函数表的大小是在编译时确定的。

类的虚函数表存放在text segment中的.rodata区。

每个对象都会有一个虚函数表指针指向该类共有的一个虚函数表，即编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。当调用虚函数时，便会通过虚表指针找到虚函数表，然后在虚函数表中找到对应的函数指针，通过这个函数指针来调用虚函数。

对于没有重写的虚函数，虚函数表中存放的是指向父类的虚函数函数指针，对于重写的虚函数，存放的是指向的派生类重写后的虚函数的函数指针。

#### 9. 普通成员函数，虚函数与纯虚函数的区别，应用场景

* 普通成员函数：普通成员函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数。
* 虚函数：虚函数为了重写和多态的需要，在基类中定义的，即便定义为空。子类中可以重写也可以不写基类中的函数。若虚函数在基类中有声明和定义，该基类是可以被实例化的。
* 纯虚函数：
  * 包含纯虚函数的类为抽象类，由于抽象类中包含了未定义的纯虚函数，所以抽象类无法实例化。纯虚函数在基类中是没有定义的，纯虚函数在基类中只有声明，没有定义，该基类无法实例化。若子类没有实现该纯虚函数，则子类也是纯虚类，且子类也无法实例化。
  * 抽象类的定义，含有纯虚函数的类被称为抽象类，抽象类只能作为派生类的基类，不能定义对象，但可以定义指针或者引用。抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性。继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那么这个派生类也就成了抽象类。因为它继承了基类的抽象函数，只要含有纯虚函数的类就是抽象类。纯虚函数已经在抽象类中定义了这个方法的声明，其它类中只能按照这个接口去实现。 
* 应用场景的区别，虚函数和纯虚函数都能实现多态性。纯虚函数更加类似于接口的抽象，其本身生成对象并不合理。

#### 10. 构造函数，拷贝构造函数可以是虚函数吗，析构函数可以是虚函数吗，析构函数为什么需要是虚函数

* 构造函数不可以为虚函数，可以从以下几个方面来说明
  * 首先从存储角度说明、所有的虚函数都要通过实例中的虚函数表来调用，如果构造函数是虚的，那就要通过虚函数表来调用，可是此时对象还没有实例化，也就是内存空间还没有，无法找到虚函数表，所以构造函数不能是虚函数。
  * 其次从使用角度讲，构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型。同理，拷贝构造函数也不能是虚函数。
* 析构函数可以是虚函数，且常常如此，若存在类的继承关系，而且基类指针指向派生类对象时，一般需要将析构函数声明为虚函数，不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题。如果不存在继承关系，而且不需要使用多态的特性时，就不要将析构函数声明为虚函数，因为虚函数本身实现需要额外的花销(如vptr)，在类本身比较小时，会造成很大额外花销的比例。一般不要继承String, Vector等库类，因为他们本身为了达到较高的效率没有将析构函数声明为虚函数，这样如果继承了会造成上述的问题。

#### 11. 构造函数，拷贝构造函数，析构函数可以调用虚函数吗

C++ primer P556。可以调用虚函数但是无法实现多态。

构造函数，拷贝构造函数以及析构函数中可以调用虚函数，但是应该尽可能避免在构造函数，拷贝构造函数以及析构函数中调用虚函数。举一个简单的例子。

```cpp
class base{
public:
    base(){
        cout<<"The size is "<<size()<<endl;
    }
private:
    virtual size_t size(){
        return sizeof(*this);
    }
};

class derived : public base{
public:
    derived(){
        cout<<"The size of is "<<size()<<endl;
    }
private:
    size_t size(){
        return sizeof(*this);
    }
};
```

当定义一个derived实例对象时，在base的构造函数中调用size()会被静态的决议为base::size()而不是derived::size()。可以这么理解，当在构造base部分时，derived并不一个完整的实例对象，derived部分的成员变量甚至没有被初始化，如果在构造base期间调用的是derived的虚函数并且该虚函数引用了尚未构造好的成员变量，试想会发生什么。所以，从安全性考虑，经由构造中的对象来调用一个虚函数，其函数就是正在构造的对象的所属函数。同时析构函数也如此。当正在析构base部分时，derived部分已经被析构完毕，成员变量已经无效，调用的虚函数是所属base的。

#### 12. 派生类中构造函数，析构函数调用顺序

派生类调用构造函数的顺序，如果是单继承，首先调用基类的构造函数，之后调用成员对象的构造函数，最后调用派生类自身的构造函数。其中成员的初始化顺序与其在类中生命的顺序有关。析构函数的调用顺序与构造函数的调用顺序相反。

如果是多重继承，同单继承的情况类似，只不过调用基类的构造函数时，按类继承表的顺序调用基类的构造函数。多重继承在C++中不常用也不推荐，因为可能会带来一些问题，基类有共同的祖先，导致二义性，此时需要采用虚拟继承避免这种问题。

#### 13. 构造函数可以抛出异常吗，析构函数能抛出异常吗

* 构造函数可以抛出异常，而且不会出现内存泄漏，C++在执行构造函数过程中产生异常，不会调用析构函数，而仅仅清理和释放产生异常前的那些C++管理的变量空间，之后把异常抛给程序处理。
* 如果析构函数抛出异常，将直接导致当前执行线程异常终止，如果主线程中发生析构异常，程序立即退出。C++标准明确指明析构函数不能也不应该抛出异常杨，有两点理由
  * （1）、如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
  * （2）、通常异常发生时，C++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
* 针对析构函数不能抛出异常的解决方案
  * （1）、如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
  * （2）、如果析构函数中异常非抛不可，那就用try catch来将异常吞下，必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。

#### 14. 指针和引用的区别，指针和数组的联系，悬空指针和野指针有什么区别

* 指针与引用的区别主要有以下几点
  * （1）、指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。
  * （2）、引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。
  * （3）、可以有const指针，但是没有const引用，这里的const是指指针本身指向的地址不变，可以由指向const对象的指针以及const对象的引用，通过指向const的指针与const对象的引用无法改变对象的值，即使对象本身是一个变量并不是常量。
  * （4）、指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）。
  * （5）、指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化。
  * （6）、指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
  * （7）、”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小。
  * （8）、指针和引用的自增(++)运算意义不一样。
  * （9）、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏。
* 指针与数组的联系，数组是数组，指针是指针，两者是不同的类型，详细描述见。https://www.cnblogs.com/zhiheng/p/6683334.html.
* 悬挂指针与野指针的区别，悬挂指针是指针指向的内存被清理，但是指针仍然指向该内存，野指针是指未初始化的指针。

#### 15. 函数指针有什么作用，有哪些属性唯一决定一个函数指针 

函数指针，指针是一个变量，是用来指向内存地址的。一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种指向函数入口地址的指针称为函数指针。

函数指针通常被用作回调函数，即作为参数传入别的函数。回调函数，顾名思义，就是使用者自己定义一个函数，使用者自己实现这个函数的程序内容，然后把这个函数作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间来回调你实现的函数。

关于函数指针的声明，声明函数指针时，只要函数返回值类型、参数个数、参数类型等保持一致，就可以声明一个函数指针了。

#### 16. 智能指针实现原理，什么时候改变引用计数，shared_ptr, unique_ptr, weak_ptr的区别？ weak_ptr主要是为了解决什么问题的？ 

C++ Primer 第12章动态内存与智能指针

**代码实现**

shared_ptr<>对原生指针以及的基础上进行了封装，智能指针指向的是原生指针以及一个引用计数，原生指针指向一个实例化的对象。利用RAII（资源获取即初始化）的技术对普通指针进行封装，主要作用避免内存泄漏、实现异常安全。

shared_ptr<>可以利用make_shared<>初始化，或利用原生指针，uniqu_ptr<>，shared_ptr<>进行显示初始化、也可以利用shared_ptr<>进行赋值。shared_ptr<>支持同类型的赋值、拷贝操作。shared_ptr<>进行构造、拷贝、赋值、reset()时会改变引用计数。

uniqu_ptr<>只能利用原生指针进行显示初始化，不支持同类型的赋值、拷贝操作。

weak_ptr<>是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr<>管理的对象但是不增加引用计数，一旦最后一个shared_ptr<>被销毁，对象就会被释放。weak_ptr<>可以用shared_ptr<>、weak_ptr<>进行初始化或赋值。weak_ptr<>中的lock()函数比较关键，如果对象还存在则返回一个指向该对象的shared_ptr<>，否则返回一个空的shared_ptr<>。可以利用weak_ptr<>来避免循环引用。

#### 17.  隐式类型转换与显示类型转换, 如何避免编译器进行的隐式类型转换？`static_cast<>`, `dynamic_cast<>`, `const_cast<>`, `reinterpret_cast<>` 的各自作用和使用环境？`dynamic_cast<>` 是如何实现运行时类型转换的？`static_cast<>` 向上向下转换时的会出现什么问题。`dynamic_cast<>` 失败的话会怎样。

[参考](https://www.cnblogs.com/TenosDoIt/p/3175217.html)

* **static_cast** 

用法：

```cpp 
static_cast < type-id > ( exdivssion ) 
```

该运算符把exdivssion转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

1. 用于类层次结构中基类和子类之间***指针或引用***的转换。

   * 进行上行转换（把子类的指针或引用转换成基类表示）是安全的；
   * 进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。

   ```cpp
   class A{
   public:
       void test(){
           cout<<"I am an object A"<<endl;
       }
   };
   
   class B: public A{
   public:
       void test(){
           cout<<"I am an object B"<<endl;
       }
   };
   
   int main
   ```

2. 用于任何类型的 object 的上行转换，这种转换是安全的，而 object 之间的下行转换是不安全的，无法被编译。

3. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证（指针不行）。

4. 把空指针转换成目标类型的空指针。

5. 把任何类型的表达式转换成void类型。

注意：static_cast 不能转换掉exdivssion的const、volitale、或者__unaligned属性。

msdn官方解释：<http://msdn.microsoft.com/en-us/library/c36yw7x9(v=vs.80).aspx>

* **dynamic_cast**

用法：

```cpp
dynamic_cast < type-id > ( exdivssion )
```

* 该运算符把exdivssion转换成type-id类型的对象。Type-id必须是***类的指针、类的引用或者void \****；
* 如果type-id是类指针类型，那么exdivssion也必须是一个指针，如果type-id是一个引用，那么exdivssion也必须是一个引用。
* dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
* 在类层次间进行上行转换时，dynamic_cast和static_cast 的效果是一样的；
* 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast 更安全。值得注意的是，进行下行转换时，`dynamic_cast<>` 需要依据虚函数表中的`type-info` 类来判断，如果类型不是多态类，会无法通过编译。
* 当为指针类型时，无法进行动态类型转换会返回 `nullptr`，而为引用时，若失败会抛出异常。

msdn官方解释：<http://msdn.microsoft.com/en-us/library/cby9kycs(v=vs.80).aspx>

* **reinterpret_cast**

用法：

```cpp
reinterpret_cast<type-id> (exdivssion)
```

reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位。按照reinterpret的字面意思“重新解释”，即对数据的比特位重新解释。

[IBM的C++指南](http://publib.boulder.ibm.com/infocenter/compbgpl/v9v111/index.jsp?topic=/com.ibm.xlcpp9.bg.doc/language_ref/keyword_reinterpret_cast.htm) 里明确告诉了我们reinterpret_cast可以，或者说应该在什么地方用来作为转换运算符：

- 从指针类型到一个足够大的整数类型
- 从整数类型或者枚举类型到指针类型
- 从一个指向函数的指针到另一个不同类型的指向函数的指针
- 从一个指向对象的指针到另一个不同类型的指向对象的指针
- 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针
- 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针

总结来说：reinterpret_cast用在任意指针（或引用）类型之间的转换；以及指针与足够大的整数类型之间的转换；从整数类型（包括枚举类型）到指针类型，无视大小。

**注意**：reinterpret_cast 不能转换掉exdivssion的const、volitale、或者__unaligned属性。

msdn官方解释：<http://msdn.microsoft.com/en-us/library/e0w9f63b(v=vs.80).aspx>

* **const_cast** 

用法：

```cpp
const_cast<type-id> (exdivssion)
```

`exdivssion` 必须为指针或者饮用水，该运算符用来修改类型的const、volatile、\_\_unaligned属性。除了const 、volatile、__unaligned修饰之外， type_id和exdivssion的类型是一样的。

* 常量指针被转化成非常量指针，并且仍然指向原来的对象；
* 常量引用被转换成非常量引用，并且仍然指向原来的对象；
* 非常量指针转化为常量指针，并且仍然指向原来的对象；
* 非常量饮用转化为常量饮用，并且仍然指向原来的对象。

msdn官方解释：<http://msdn.microsoft.com/en-us/library/bz6at95h(v=vs.80).aspx>

#### 18. 函数压栈的过程，类的成员函数的压栈过程，\_\_stdcall，\_\_cdecl，\_\_fastcall，thiscall，naked call的作用以及区别，this指针怎么处理

[参考](https://www.cnblogs.com/Winston/archive/2008/09/11/1289391.html)，[参考1](https://blog.csdn.net/daiafei/article/details/5364587)

1. \_\_stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，函数采用从右到左的压栈方式，自己在退出时清空堆栈。VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上"@"和参数的字节数。

2. C调用约定（即用\_\_cdecl关键字说明）按从右至左的顺序压参数入栈，由调用者把参数弹出栈。对于传送参数的内存栈是由调用者来维护的（正因为如此，实现可变参数的函数只能使用该调用约定）。另外，在函数名修饰约定方面也有所不同。

   **\_\_cdecl**是C和C＋＋程序的缺省调用方式。每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用\_\_stdcall函数的大。函数采用从右到左的压栈方式。VC将函数编译后会在函数名前面加上下划线前缀。是MFC缺省调用约定。

3. \_\_fastcall调用约定是“人”如其名，它的主要特点就是快，因为它是通过寄存器来传送参数的（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈），在函数名修饰约定方面，它和前两者均不同。

   \_\_fastcall方式的函数采用寄存器传递参数，VC将函数编译后会在函数名前面加上"@"前缀，在函数名后加上"@"和参数的字节数。   

4. thiscall仅仅应用于“C++”成员函数。this指针存放于ECX寄存器，参数从右到左压。thiscall不是关键词，因此不能被程序员指定。

5. naked call采用1-4的调用约定时，如果必要的话，进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器，退出函数时则产生代码恢复这些寄存器的内容。naked call不产生这样的代码。naked call不是类型修饰符，故必须和\_\_declspec共同使用。

#### 19. 成员函数可以调用delete this吗？为什么？

* 成员函数中可以调用delete this，但是有几点需要注意，调用delete this时相当于调用了该对象的析构函数。要确保
  * （1）、确保对象是new出来的，即对象要建立在堆上，vs2017下实验建立在栈上的对象delete this会产生异常。
  * （2）、确保delete完后不会用该对象调用其它（非静态）成员函数，vs2017下实验delete this之后仍然可以访问其成员函数，以及成员变量，但是成员变量的值为随机值，但是仍然建议不要这么做。
  * （3）、确保delete完后不能访问对象的任何部分，vs2017下实验可以访问，但是仍然建议不要这么做。
  * （4）、确保delete完后this指针不会被访问，vs2017下实验，this指针仍能被访问，但是不建议这么做。 

#### 21. 什么是内存泄漏？造成内存泄漏的常见原因？如何检测，定位内存泄漏？对一个数组而言，delete a和delete[] a有什么区别？为什么？

* 内存泄漏

  * 内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
  * 内存泄漏的后果，最难捉摸也最难检测到的错误之一是内存泄漏，即未能正确释放以前分配的内存的 bug。 只发生一次的小的内存泄漏可能不会被注意，但泄漏大量内存的程序或泄漏日益增多的程序可能会表现出各种征兆：从性能不良（并且逐渐降低）到内存完全用尽。 更糟的是，泄漏的程序可能会用掉太多内存，以致另一个程序失败，而使用户无从查找问题的真正根源。 此外，即使无害的内存泄漏也可能是其他问题的征兆。

* 内存泄漏常见的一些原因

  1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数，两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显式地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存。
  2. 没有正确地清除嵌套的对象指针。
  3. 在释放对象数组时在delete中没有使用方括号，方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值病调用对象的析构函数，如果没有方括号，那么数组中的对象同样会被清除，但是不会调用它的析构函数，如果该对象申请了堆上的内存，那么这些内存不会被释放，从而造成了内存泄漏。
  4. 指向对象的指针数组不等同于对象数组，对象数组是指数组中存放的是对象，只需要 `delete[] p`，即可调用对象数组中的每个对象的析构函数释放空间，指向对象的指针数组是指数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，`delete[] p`只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。
  5. 使用默认赋值运算符进行了浅复制，造成了内存泄漏。
  6. 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

* 检测定位内存泄漏

  * Windows

    以下内容来自https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html

    Windows平台下检测与定位内存泄漏，Windows平台下面 Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏

  * Linux

    Linux平台下检测与定位内存泄漏，有类似于windows下的方法，mtrace，<http://en.wikipedia.org/wiki/Mtrace>，或者使用另一个非常强大的工具 valgrind，Valgrind的使用请见手册 http://valgrind.org/docs/manual/manual.html. 

* `new/delete`，`new[]/delete[]`. [参考](https://blog.csdn.net/hazir/article/details/21413833)

  * 这里说的使用 `new []` 用 `delete` 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！
  * 如果定义了析构函数的类型，能否编译成功是个问题，如果能够编译通过，而且数组内的对象没有申请堆上的内存，直接使用`delete`不会造成内存泄漏，但是这样的做法十分不可取，注意配对使用。
  * 在C++11之后，尽量避免使用裸指针，最好使用智能指针，若涉及到多线程，也要注意使用智能指针时的线程安全。

#### 22. 定义一个空类，C++到底默默编写了哪些成员，这些函数都做了什么？

对于一个空类，会生成一个1个字节的占位符，当定义一个空类时，C++会默默地编写六个成员，分别是默认构造函数，析构函数，拷贝构造函数，重载赋值运算符，一对取址运算符以及一个this指针。 

* 默认构造函数
* 默认拷贝构造函数
* 默认赋值运算符
* 默认析构函数
* & 运算符
* this 指针

#### 23. C++类中数据成员初始化顺序？ 类的内存结构？菱形继承，多继承会带来什么问题？private 继承又会带来什么问题。 

* C++类中数据成员的初始化顺序

  不管类成员在初始化列表中的顺序如何，初始化的顺序是在类中声明的顺序。

  1. 基类的静态变量或全局变量。
  2. 派生类的静态变量或全局变量。
  3. 基类的成员变量。
  4. 派生类的成员变量。
  5. 存在虚继承时，虚基类中的成员会被最后初始化。

* 类的内存结构

  [参考](<https://www.cnblogs.com/freeopen/p/5482965.html> )

  * 没有虚函数的类的内存结构
  * 含有虚函数的类的内存结构（单继承，多重继承）
  * 涉及到虚继承的类的内存结构（单继承，多重继承）

* 菱形继承，多重继承带来的问题

  * 零星继承，多重继承所带来的最为常见的问题便是二义性问题，解决措施有

  1. 类名限定，调用时指名调用的是哪个类的成员函数或者成员数据。 
  2. 同名覆盖，在派生类中声明一个同名成员，该函数根据需要内部调用基类中的函数。 
  3. 如果是菱形继承带来的二义性问题，可以通过虚继承来避免。

* 私有继承带来的问题

  私有继承后，派生类的实例化对象是无法访问基类的任一成员的（包括public）。派生类本身是能够访问基类的public和protected成员的。在Effective C++39中指出

  1. 如果类之间是private继承，则编译器不会自动将一个派生类对象转换成一个基类对象，基类中的所有成员在派生类中都具有private属性，派生类的对象无法访问。
  2. private表现出的关系是“根据某物实现出”，他继承的是实现而非接口。
  3. private继承主要用于两个类不存在is-a的关系。 

#### 24. 内存对齐的作用，内存对齐的原则，类/结构体/共同体内存对齐问题，结构体/类/共同体大小的计算？

[参考1](<https://www.cnblogs.com/xylc/p/3780907.html>)，[参考2](<https://www.cnblogs.com/zrtqsk/p/4371773.html>)

* 内存对齐的作用，
  * 平台原因，不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
  * 效率原因，是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。比如对于int x;（这里假设sizeof(int)==4），因为cpu对内存的读取操作是对齐的，如果x的地址不是4的倍数，那么读取这个x，需要读取两次共8个字节，然后还要将其拼接成一个int，这比存取对齐过的x要麻烦很多。
* 内存对齐的原则
  * 第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
  * 在数据成员完成各自对齐之后，类(结构或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。很明显#pragma pack(n)作为一个预编译指令用来设置多少个字节对齐的。值得注意的是，n的缺省数值是按照编译器自身设置，一般为8，合法的数值分别是1、2、4、8、16。即编译器只会按照1、2、4、8、16的方式分割内存。若n为其他值，是无效的。
  * 对于共同体，其内存对齐时按照内部字节数最大的成员进行对齐。 

#### 27. 深复制与浅复制的区别？

浅复制：复制之后，指向的对象仍为同一个。

深复制：复制之后，指向的对象不再是同一个，彼此的修改互不影响。

#### 29. virtual, inline, decltype, volatile, static, const, extern, extern “C”, define关键字的作用？使用场景？static和const区别？ const和define的区别？inline和define的区别？ C++中有哪些机制可以取代宏？

* virtual：该关键字有三个用法。1、虚函数，2、纯虚函数，3、虚继承。具体用法见<https://www.cnblogs.com/Yogurshine/archive/2013/01/10/2855654.html> 
* inline：内联函数，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。具体见<https://www.cnblogs.com/chenhuan001/p/6502142.html> 
* decltype：C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。具体用法见<https://www.cnblogs.com/cauchy007/p/4966485.html> 
* volatile：C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，确保编译器每次都从内存中读取该值。具体见<https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html> 
* static：C++的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。面向过程设计中的static，静态全局变量，静态局部变量，静态函数。面向对象的static关键字，静态数据成员，静态成员函数。具体见<https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html> 
* const：cont作用如下，修饰常量，修饰指针，修饰引用，修饰函数参数，修饰函数返回值，修饰类成员变量，修饰类成员函数，修饰类对象，在类内重载成员函数。具体见<https://www.cnblogs.com/chogen/p/4574118.html> 
* extern：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。具体见<https://www.cnblogs.com/broglie/p/5524932.html> <https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html> 
* extern “C” 为了实现C和C++的混合编程，在C++源文件中的语句前面加上extern "C"，表明它按照类C的编译和连接规约来编译和连接。具体见<https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html>
* define 宏定义，简单的理解就是替换，其实这也是本质。如果熟悉g++编译过程的话，会了解到一个概念叫做预处理，就是在编译之前做个处理。这个过程并不像编译那么复杂，就是简单的递归替换和删除。替换的就是宏定义和include文件，删除注释。主要有一下几个作用，1、简单使用，2、带参使用。具体见<https://www.cnblogs.com/liboBlog/p/6139726.html> 
* const和static的区别，const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static。在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。具体见<https://www.cnblogs.com/phpzhou/p/6390869.html> 
* const和define的区别，就定义常量说的话，const定义的常数是变量，也带类型， #define定义的只是个常数，不带类型。就起作用的阶段而言：define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。就起作用的方式而言：#define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。就空间占用而言：#define占用代码段空间，const占用数据段空间。从代码调试的方便程度而言：const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。从是否可以再定义的角度而言：const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。从某些特殊功能而言：#define可以用来防止头文件重复引用，而const不能。从某些复杂功能的实现的实现角度来看：使用define会使得代码看起来非常简单，而const无法实现该功能。具体见<http://blog.csdn.net/yi_ming_he/article/details/70405364> 
* inline和define的区别，内联函数在编译时展开，而宏是由预处理器对宏进行展开。内联函数会检查参数类型，宏定义不检查函数参数，所以内联函数更安全。宏不是函数，而inline函数是函数。宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。内联函数对编译器提出建议，编译器有权拒绝进行替换。<https://www.cnblogs.com/iloveyoucc/archive/2012/03/18/2404658.html> <http://blog.csdn.net/shiyang6017/article/details/52893231> 
* C++中有哪些机制可以取代宏，常量定义可以用const代替，内联函数可以用inline代替，类型重定义可以用typeded代替，条件编译可以用模板特化来实现，头文件重复包含在部分编译器下可以用#pragma once来代替。具体见<https://www.cnblogs.com/lovers-space/archive/2012/12/23/2829859.html> 

#### 31. struct和class的区别？

[参考](<http://blog.csdn.net/wangpengcsdn1/article/details/68935318>)

c++中的struct和class差别不大，主要差别集中在

1. 成员初始化方式不同，
2. 默认访问权限不同，
3. 默认继承方式不同。 

#### C++中堆和自由存储区的区别 

[参考](<http://www.cnblogs.com/QG-whz/p/5060894.html>  )

从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。

结论

* 自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
* new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
* 堆与自由存储区还是有区别的，它们并非等价。

#### 如果`new`申请内存失败了，如何去解决？如果让你实现一个`new`，你会怎么实现？

 [参考](<http://blog.jobbole.com/106767/> )

C++中一提到new，至少可能代表以下三种含义：new operator、operator new、placement new。

* new operator不能更改，operator new、placement new是可以重载的。
* operator new的默认行为是请求分配内存，如果成功则返回此内存地址，如果失败则调用一个new_handler，new_handler函数指针可以指向客户所希望的函数来处理内存申请失败的情况。new_handler中可以抛出bad_alloc异常或者调用exit()或类似的函数，使程序结束
* new的实现其实可以分为3步，第一步调用operator new，operator new的作用是申请内存，之后调用placement new，最后返回指针。

#### 32. malloc和new的区别？ free和delete的区别？free一个数组时如何知道要释放多大的内存呢？

[参考](<http://blog.jobbole.com/102002/> )

* malloc和new的区别

  new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。它们都可用于申请动态内存和释放内存。 

  1. **申请的内存所在位置**

  new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：

  ```cpp
  new (place_address) type
  ```

  `place_address` 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的 placement new，也就是下面这个版本：

  ```cpp
  void * operator new (size_t,void *) //不允许重定义这个版本的operator new
  ```

  这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。

  2. **返回类型的区别**

  new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

  3. **内存分配失败时的返回值**

  new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：

  ```cpp
  int *a=(int *)malloc(sizeof(int));
  if(NULL==a){
      ...
  }else{
      ...
  }
  ```

  从C语言走入C++阵营的新手可能会把这个习惯带入C++，实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：

  ```cpp
  try{
      int *a=new int();
  }
  catch(bac_alloc){
      ...
  }
  ```

  4. **是否需要指定内存大小**

  使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

  ```cpp
  class A{
      ...
  }
  
  A* p= new A();
  A* p= (A *)malloc(sizeof(A));//需要显式指定所需内存大小sizeof(A)
  ```

  5. **是否调用构造函数，析构函数**

  使用new操作符来分配对象内存时会经历三个步骤：

  第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。

  第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。

  第三步：对象构造完成后，返回一个指向该对象的指针。

  使用delete操作符来释放对象内存时会经历两个步骤：

  第一步：调用对象的析构函数。

  第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

  总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：

  6.**和数组有关的处理**

  C++提供了new[]与delete[]来专门处理数组类型:

  ```cpp
  A * ptr = new A[10];//分配10个A对象
  ```

  使用new[]分配的内存必须使用delete[]进行释放：

  ```cpp
  delete [] ptr;
  ```

  new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

  至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

  ```cpp
  int* p= (int*)maclloc(sizeof(int)*10);//分配一个10个int元素的数组
  ```

  7. **`new`与`malloc`是否可以相互调用**

  operator new的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new 的一种简单方式，其他版本也与之类似：

  ```cpp
  void* operator new(size_t size){
      if(void * mem=malloc(size))
          return mem;
      else
          throw bad_alloc();
  }
  ```

  8. **是否可以被重载**

  opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：

  ```cpp
  //以下版本可能抛出异常
  void* operator new(size_t);
  void* operator new[](size_t);
  void* operator delete(void*);
  void* operator delete[](void*);
  //以下版本承诺不抛出异常
  void* operator new(size_t, nothrow_t&) noexcept;
  void* operator new[](size_t, nothrow_t&) noexcept;
  void* operator delete(void*, nothrow_t&) noexcept;
  void* operator delete[](void*, nothrow_t&) noexcept;
  ```

  而malloc/free并不允许重载。

  9. **能够直接重新分配内存**

  使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。

  new没有这样直观的配套设施来扩充内存。

  10.**客户处理内存分配不足**

  在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个函数指针：

  ```cpp
  namespace std{
      typedef void(*new_handler)();
  }
  ```

  指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:

  ```cpp
  namespace std{
      new_handler set_newhandler(new_handler p) throw();
  }
  ```

  set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。

  对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

* free 和 delete 的区别

  [参考](http://blog.csdn.net/gukesdo/article/details/7506155) 

  * 应用的区别为：

  1. 数组的时候`int *p=(int*)malloc(10*sizeof(int))` 释放的时候 `free(p)` 即可；这是因为编译器对malloc做了一些特殊的处理，以保证可以正确释放内存。而当 `int *p=new int[10]` 释放的时候应为`delete []p`，注意`[]`的作用说明释放的是一个数组的内存。
  2. 在处理类和对象的时候会有很大区别。在使用`malloc`和`free`来处理动态内存的时候，仅仅是释放了这个对象所占的内存，而不会调用这个对象的析构函数；使用`new`和`delete`就可以既释放对象的内存的同时，调用这个对象的析构函数。

  * 共同之处：

    它们都是只把指针所指向的内存释放掉了，并没有把指针本身干掉。在`free`和`delete`之后，都需要把指向清理内存的指针置为空，即`p=nullptr`，否则指针指向的内存空间虽然释放了，但是指针p的值还是记录的那块地址，该地址对应的内存是垃圾，`p`就成了“野指针”。同样会使人认为`p`是个合法的指针，如果程序较长，我们通常在使用一个指针前会检查`p!=NULL`，这样就起不到作用了。此时如果再释放`p`指向的空间，编译器就会报错，因为释放一个已经被释放过的空间是不合法的。而将其置为`NULL`之后再重复释放就不会产生问题，因为delete一个0指针是安全的。

    | **特征**             | **new/delete**                        | **malloc/free**                      |
    | -------------------- | ------------------------------------- | ------------------------------------ |
    | 分配内存的位置       | 自由存储区                            | 堆                                   |
    | 内存分配成功的返回值 | 完整类型指针                          | void*                                |
    | 内存分配失败的返回值 | 默认抛出异常                          | 返回NULL                             |
    | 分配内存的大小       | 由编译器根据类型计算得出              | 必须显式指定字节数                   |
    | 处理数组             | 有处理数组的new版本new[]              | 需要用户计算数组的大小后进行内存分配 |
    | 已分配内存的扩充     | 无法直观地处理                        | 使用realloc简单完成                  |
    | 是否相互调用         | 可以，看具体的operator new/delete实现 | 不可调用new                          |
    | 分配内存时内存不足   | 客户能够指定处理函数或重新制定分配器  | 无法通过用户代码进行处理             |
    | 函数重载             | 允许                                  | 不允许                               |
    | 构造函数与析构函数   | 调用                                  | 不调用                               |

* 关于 free() 函数怎么知道释放多大的内存

  [参考](<http://blog.163.com/hezhixiongbei@126/blog/static/73213307201542712252663/> )

  在C语言里动态内存申请和释放函数为malloc()和free()函数，其函数原型分别为：

  ```cpp
  void *malloc( size_t size );       // 参数size为需要申请内存空间的数量
  void free( void* memblock );    // 参数memblock为需要释放内存的指针
  ```

  内存申请时指定了申请多少内存空间，但是free()释放内存时却不需要指定释放多少内存空间，而只需要传递一个指向该块内存首地址的指针。这是因为编译器在申请内存时把申请内存数量的值保存起来了，所以内存释放时只需要指定内存首地址即可。申请内存数量的值通常保存在内存块首地址前0x10的位置，即首地址前第16个字节的位置。

#### 34. `sizeof` 和 `strlen` 的区别

[参考](<http://blog.csdn.net/u012441543/article/details/45848913>  )

`sizeof` 是关键字，`strlen` 是函数。

* `strlen` 是函数，`strlen(char*)` 函数求的是字符串的实际长度，直到遇到第一个 `'\0'`，然后就返回计数值，且不包括 `'\0'`，函数的返回值值在运行时确定。参数是指针或字符数组，当数组名作为参数传入时，实际上数组就退化成指针了。
* `sizeof` 是操作符，不是函数，返回的是变量声明后所占的内存数，不是实际长度。其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。当计算数组的size时，数组不会退化成指针。

```cpp
#include <iostream>
#include <string.h>

using namespace std;

int main(){
    char arr[20]="hello world!";
    cout<<strlen(arr)<<endl;//返回12，因为不包括'\0'
    cout<<sizeof(arr)<<endl;//返回20，因为arr占据了20个字节的空间
    
    cout<<strlen("hello")<<endl;//返回5
    cout<<sizeof("hello")<<endl;//返回6
    
    char *p="hello";
    cout<<strlen(p)<<endl;//返回5
    cout<<sizeof(p)<<endl;//返回4或者8，指针的大小
}
```

#### 37. 常对象的成员变量一定不可以修改吗？

可以修改，利用关键字mutable。[参考](<http://blog.csdn.net/huangyimo/article/details/52154821> )

#### 38. C++中有哪些容器（顺序容器，关联容器，容器适配器）

[参考](<http://blog.csdn.net/u010398493/article/details/52298744> )，[底层数据结构](https://blog.csdn.net/yujin753/article/details/43203079)

* 顺序容器有vector，deque，list
* 关联容器有set，map，unordered_set，unordered_map
* 容器适配器有stack，queue，priority_queue。

#### 39. `vector`，`list`，`deque` 的区别？

[参考](<http://blog.csdn.net/u010398493/article/details/52298744> )

* vector向量相当于一个数组，在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacity（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。
  * 优点：
    * (1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()。
    * (2) 随机访问方便，即支持[ ]操作符和vector.at()。
    * (3) 节省空间。
  * 缺点：
    * (1) 在内部进行插入删除操作效率低。
    * (2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。
    * (3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放。
* list 双向链表，每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。
  * 优点：
    * (1) 不使用连续内存完成动态操作。
    * (2) 在内部方便的进行插入和删除操作。
    * (3) 可在两端进行push、pop
  * 缺点：
    * (1) 不能进行内部的随机访问，即不支持[ ]操作符。
    * (2) 相对于verctor占用内存多。
* deque双端队列，deque是在功能上合并了vector和list。
  * 优点：
    * (1) 随机访问方便，即支持[ ]操作符。
    * (2) 在内部方便的进行插入和删除操作。
    * (3) 可在两端进行push、pop。
  * 缺点：
    * (1) 占用内存多。
* 三个容器使用时的注意事项
  * 1）如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。
  * 2）如果需要大量的插入和删除，而不关心随机存取，则应使用list。
  * 3）如果需要随机存取，而且关心两端数据的插入和删除，则应使用deque。
* 三者的比较
  * vector 是一段连续的内存块，而deque 是多个连续的内存块， list 是所有数据元素分开保存，可以是任何两个元素没有连续。vector 的查询性能最好，并且在末端增加数据也很好，除非它重新申请内存段；适合高效地随机存储。
  * list 是一个链表，任何一个元素都可以是不连续的，但它都有两个指向上一元素和下一元素的指针。所以它对插入、删除元素性能是最好的，而查询性能非常差；适合 大量地插入和删除操作而不关心随机存取的需求。
  * deque 是介于两者之间，它兼顾了数组和链表的优点，它是分块的链表和多个数组的联合。所以它有比list 好的查询性能，有比vector 好的插入、删除性能。 如果你需要随即存取又关心两端数据的插入和删除，那么deque 是最佳之选。

#### 40.` const vector<Type>` 和`vector <const Type>`的区别

[参考](<https://stackoverflow.com/questions/6954906/does-c11-allow-vectorconst-t> )

* `const vector<Type>` 表明vector本身是一个常量，只能读取，不能修改，也不能增删元素。
* `vector <const Type>` 是不合法的在C++11标准下，因为vector底层的空间配置器要求T必须为非常量、非引用的类型。

#### 41. `vector` 扩容1.5倍与2倍各有什么优缺点？`vector` 的数组是怎么增长的？ 简述`vector.reserve()` 函数的作用？`vector` 是怎么释放多余的空间？

[1](<http://blog.csdn.net/dengheCSDN/article/details/78985684> )，[2](<https://www.zhihu.com/question/36538542> )，[3](<http://blog.csdn.net/qq_26849233/article/details/70738621> )，[4](<http://blog.csdn.net/bzhxuexi/article/details/40742161>)

* 1.5倍扩容相较于2倍的优势在于，在几次扩展之后，可以重用之前的内存空间。
* 1.5倍扩容与2倍扩容的 `push_back()` 平均时间复杂度均为常数时间，2倍扩容的常数因子更小。
* `vector` 数组可以实现动态增长，`size()` 函数返回的是已用空间大小，`capacity()` 返回的是总空间大小，`capacity()-size()` 则是剩余的可用空间大小。当 `size()` 和 `capacity()` 相等，说明 `vector` 目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。此时会调用空间配置器重新分配空间，将所有元素拷贝至新的空间，并释放旧的空间。
* `reserve(n)` 预先分配一块较大的指定大小的内存空间，其中 `n` 为分配空间大小。
* 由于vector的内存占用空间只增不减，所有内存空间是在 `vector` 析构 时候才能被系统回收。`empty()` 用来检测容器是否为空的，`clear()` 可以清空所有元素。但是即使 `clear()`，`vector` 所占用的内存空间依然如故，无法保证内存的回收。可以用 `swap()` 来帮助释放内存。

```cpp
vector<Point>().swap(pointVec);
```

* 如果 `vector` 中存放的是指针，那么当 `vector` 销毁时，这些指针指向的对象不会被销毁，那么内存就不会被释放，造成内存泄露。所以销毁 `vector` 之前，首先释放 `vector` 内指针所指向的空间。

#### 42. set, map, unordered_set, unordered_map 底层是什么结构？set和unordered_set的区别？map和unordered_map的性能区别？ 

[参考](http://www.cppblog.com/Solstice/archive/2013/01/20/197422.html)

* set, map 的地层结构是红黑树，
* unordered_set, unordered_map 的地层结构是哈希表，

| 容器/操作     | 插入      | 删除      | 查找      | 是否支持顺序遍历 |
| ------------- | --------- | --------- | --------- | ---------------- |
| map           | O(log(n)) | O(log(n)) | O(log(n)) | 支持             |
| unordered_map | O(1)      | O(1)      | O(1)      | 不支持           |

#### hash如何避免冲突？

* 线性探查
* 二次探查

* 开链法

#### 在使用容器删除元素时，如何避免迭代器失效

[参考](https://blog.csdn.net/xocoder/article/details/8533849)

* **序列性容器::(vector和list和deque)**

  erase迭代器不仅使所有指向被删元素的迭代器失效，而且使被删元素之后的所有迭代器失效，所以不能使用erase(iter++)的方式，但是erase的返回值为下一个有效的迭代器，所以

   **正确方法为::**

   ```cpp
  for(auto iter=c.begin();iter!=c.end()){
      iter=c.erase(iter);
  }
   ```

* **关联性容器::(map和set比较常用)**

  erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器， 

  **正确方法为::**

  ```cpp
  for(auto iter=c.begin();iter!=c.end()){
      erase(iter++);
  } 
  ```

* **Tips:**

  其实对于list两种方式都可以正常工作

#### 43. 二叉查找树，AVL树，红黑树，B树，B+树的特征是什么？

[参考](https://blog.csdn.net/whoamiyang/article/details/51926985)

* 二叉查找树

  * 简介
    * 任意节点左子树不为空,则左子树的值均小于根节点的值.
    * 任意节点右子树不为空,则右子树的值均大于于根节点的值.
    * 任意节点的左右子树也分别是二叉查找树.
    * 没有键值相等的节点.

  * 局限以及应用

  一个二叉查找树是由n个节点**随机构成**,所以，对于某些情况,二叉查找树会退化成一个有n个节点的线性链.如下图: 

  ![43](image/20160717085412308.jpg)

  b图为一个普通的二叉查找树,大家看a图,如果我们的根节点选择是最小或者最大的数,那么二叉查找树就完全退化成了线性结构,因此,在二叉查找树的基础上,又出现了AVL树,红黑树,它们两个都是基于二叉查找树,只是在二叉查找树的基础上又对其做了限制.

* AVL 树

  * 简介

  AVL树是带有平衡条件的二叉查找树,一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡,左右子树树高不超过1,和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过1).不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。

  ![43.2](image/20160717080221088)

  * 局限

  由于维护这种高度平衡所付出的代价比从中获得的效率收益还大,故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树.当然,如果应用场景中对插入删除不频繁,只是对查找要求较高,那么AVL还是较优于红黑树.

  * 应用

  Windows NT内核中广泛存在，最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。

* 红黑树

  * 简介

  一种二叉查找树,但在每个节点增加一个存储位表示节点的颜色，可以是red或black。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍。它是一种弱平衡二叉树(**由于是若平衡,可以推出,相同的节点情况下，AVL树的高度低于红黑树**)，相对于要求严格的AVL树来说，它的旋转次数变少，所以对于搜索，插入，删除操作多的情况下，我们就用红黑树。

  * 性质
    * 每个节点非红即黑.
    * 根节点是黑的。
    * 每个叶节点(**叶节点即树尾端NUL指针或NULL节点**)都是黑的.
    * 如果一个节点是红的,那么它的两儿子都是黑的.
    * 对于任意节点而言,其到叶子点树NIL指针的每条路径都包含相同数目的黑节点. 

  ![43.3](image/20160717102628283)

  * 应用
    * 广泛用于C++的STL中，map和set都是用红黑树实现的。
    * 著名的linux进程调度[Completely Fair Scheduler](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler)，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间。
    * IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查。
    * ngnix中，用红黑树管理timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器。
    * java中TreeMap的实现。

   

* B 树

  * 简介

  B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉，B树每个内节点有多个分支)，与红黑树相比，在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度(**在下面B/B+树的性能分析中会提到**)。B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以B树的操作效率取决于访问磁盘的次数,关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。

  * 性质
    * 定义任意非叶子结点最多只有M个儿子；且M>2；
    * 根结点的儿子数为[2, M]；
    * 除根结点以外的非叶子结点的儿子数为[M/2, M]；
    * 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）
    * 非叶子结点的关键字个数=指向儿子的指针个数-1；
    * 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
    * 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
    * 所有叶子结点位于同一层； 

  ![43.4](image/20160717221704993)

* B+ 树

  * 简介

  B+树是应文件系统所需而产生的一种B树的变形树(**文件的目录一级一级索引,只有最底层的叶子节点(文件)保存数据。**)，非叶子节点只保存**索引，**不保存实际的数据，数据都保存在叶子节点中。这不就是文件系统文件的查找吗？我们就举个文件查找的例子：有3个文件夹，a，b，c， a包含b，b包含c，一个文件yang.c， a，b，c就是索引(存储在非叶子节点), a，b，c只是要找到的yang.c的key，而实际的数据yang.c存储在叶子节点上。 **所有的非叶子节点都可以看成索引部分**

  * 性质
    * 非叶子节点的子树指针与关键字个数相同;
    * 非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；
    * 为所有叶子节点增加一个链指针.
    * 所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的);
    * 非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层.
    * 更适合于文件系统; 

  ![43.5](image/20160718090407007)

  * 应用

  B和B+树主要用在文件系统以及数据库做索引.比如Mysql;

  * 性能分析
    * n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1； 　　
    * 若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此.因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt)),而m/lgt>1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。

  * #### 为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据索引.　　

    - B+-tree的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了.
    - 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 
    - ps:我在知乎上看到有人是这样说的,我感觉说的也挺有道理的：
      他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。　

#### AVL 树，红黑树，哈希表代码实现。

[AVL](https://www.cnblogs.com/skywang12345/p/3577360.html)，[红黑树](https://www.cnblogs.com/skywang12345/p/3624291.html)，[哈希表](http://www.it165.net/pro/html/201611/76982.html)。

#### 哈夫曼树，哈夫曼编码。

[参考](https://blog.csdn.net/joson793847469/article/details/52611430)，[参考1](https://www.cnblogs.com/wuyuankun/p/3982216.html)

#### 44. string a；字符串a这是存在哪里的。为什么在a在栈上，但是在动态增长的时候，栈不会溢出？ C++中可以继承string类吗？为什么？

* 在栈上存储的只有和字符串相关的三个迭代器，而字符串则存储在堆上，所以动态增长时并不会造成栈溢出。
* 可以继承，但是不建议这么做，首先是因为 `string` 本事不是一个多态类，无法实现多态，其次是因为 `string` 的设计并没有为继承做考虑，不方便进行扩展。

#### 46. Do{}while(0)的用法有哪些？

[参考](https://www.cnblogs.com/charlesblc/p/6080315.html)

* 主要作用是放在宏定义里面，避免宏带来的语法问题。

  在开源软件里面经常可以看到这样的写法。

  ```cpp
  #define X(a) do { f1(a); f2(a); } while(0)
  ```

  比如

  ```cpp
  #define DOSOMETHING()\
  				cmd1;\
  				cmd2;
  ```

  而如下调用的时候，会有问题，需要用到上面提到的宏定义

  ```cpp
  if(a>0)
      DOSOMETHING();
  ```

* 还有一个重要原因是，可以用来取代goto跳转。

  比如下面带goto的代码：

  ```cpp
  int foo()
  {
      somestruct* ptr = malloc(...);
   
      dosomething...;
      if(error)
      {
          goto END;
      }
   
      dosomething...;
      if(error)
      {
          goto END;
      }
      dosomething...;
   
  END:
      free(ptr);
      return 0;
   
  }
  ```

  可以利用do...while(0)和break的配合，写成：

  ```cpp
  int foo()
  {
   
      somestruct* ptr = malloc(...);
   
      do{
          dosomething...;
          if(error)
          {
              break;
          }
   
          dosomething...;
          if(error)
          {
              break;
          }
          dosomething...;
      }while(0);
   
      free(ptr);
      return 0;
   
  }
  ```

  goto转换为do...while+break，在程序结构上、编译优化上，都有很多好处。我觉得。 

* 避免空宏引起的warning

  内核中由于不同架构的限制，很多时候会用到空宏，在编译的时候，空宏会给出warning，为了避免这样的warning，就可以使用do{}while(0)来定义空宏：

  ```cpp
  #define EMPTYMICRO do{}while(0)
  ```

  我觉得，这个也可以用if-else来代替。

* 定义一个单独的函数块来实现复杂的操作，避免作用域或者命名空间冲突

  当你的功能很复杂，变量很多你又不愿意增加一个函数的时候，使用do{}while(0);，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。

#### 47. 模板和实现可不可以不写在一个文件里面？为什么？

[参考](http://aristotle0.github.io/2014/12/20/2014-12-20-separation-of-defintion-and-declaration-of-template/)

必须强调的是：

- *目前，最好的方式还是把整个模板的定义和实现都放在一个头文件中。*
- *以下方式基本上只会让你的程序变得混乱，除非万不得已，还是不用为好。*

可以将模板的成员函数的定义放在`.cc`文件中，然后添加一行实例化声明。以上面为例，
将成员函数放到`Foo.cc`文件中，在最后添加一行：

```CPP
template class Foo<int>;
```

或者只是将成员函数放到`Foo.cc`文件中，然后新建一个文件，例如`Foo-impl.cc`

```CPP
// Foo-impl.cc
#include "Foo.cc"
template class Foo<int>;
```

#### 48. 如果在构造函数中调用 `memset(this, 0, sizeof(*this))` 来初始化内存空间，有什么问题吗？ 

[参考](https://blog.csdn.net/csdn_chai/article/details/77904512)

慎用 `memset(this, 0, sizeof(*this))`

* 类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常
* 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

#### 49. C语言中，`struct{char a[0];}` 的作用？有什么好处？

[参考](https://blog.csdn.net/tgxallen/article/details/69668549)

```cpp
struct Mydata{
    int nlen;
    char data[0];
}
```

在结构中，data是一个数组名；但该数组没有元素；该数组的真实地址紧随结构体MyData之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。

```cpp
#include <iostream>

using namespace std;

struct MyData 
{
    int nLen;
    char data[0];
};

int main()
{
    int nLen = 10;
    char str[10] = "123456789";

    cout << "Size of MyData: " << sizeof(MyData) << endl;

    MyData *myData = (MyData*)malloc(sizeof(MyData) + 10);
    memcpy(myData->data,  str, 10);

    cout << "myData's Data is: " << myData->data << endl;

    free(myData);

    return 0;
}
```

输出

```
Size of MyData: 4
myData's Data is: 123456789
```

由于数组没有元素，该数组在该结构体中分配占用空间，所以sizeof(struct Mydata) = 4。

malloc申请的是14个字节的连续空间，它返回一个指针指向这14个字节，强制转换成struct INFO的时候，前面4个字节被认为是Mydata结构，后面的部分拷贝了“123456789”的内容。

#### 50. 如何判断两个浮点数相等？浮点数为什么会有误差？

[参考](https://blog.csdn.net/YhL_Leo/article/details/50255623)

* **除了可以表示为2的幂次以及整数数乘的浮点数可以准确表示外，其余的数的值都是近似值。**
* 例如，`1.5` 可以精确表示，因为 `1.5 = 3*2^(-1)`；然而 `3.6` 却不能精确表示，因为它并不满足这一规则。 

#### 52. 什么是类型安全？能举例吗？

[参考](http://alexiachen.github.io/blog/2017/03/16/type-safety/)

C/C++ 不是类型安全的

* 非类型安全，C语言的类型系统不对无意义的行为做约束，例子数组越界。而C++可以认为是C语言的超集（为了兼容垃圾C语言这个历史包袱不得不作出的妥协），也没有对数组下标越界作出约束，所以也是非类型安全的。当然还有为了兼容C，C++允许随意的强制类型转换很容易破坏类型系统。所以更加类型安全的类型转换，dynamic_cast, static_cast, const_cast等。

#### 53. 虚函数表是在什么时候确定的？那虚表指针呢？

[参考](https://blog.csdn.net/qq_34484472/article/details/78232465)

* 虚函数表是编译时确定。
* 虚表指针是运行时确定。

#### 54. 如何检查内存泄露？如果不通过printf,debug等调试方式和编译器报错提示呢？ 

[参考](https://www.zhihu.com/question/29859828)

#### 55. `int(*f(int,void(*)()))(int,int)`是什么意思？`char* const*(*next)()` 是什么？ 如何判断const所修饰的对象？

[参考](https://www.xuebuyuan.com/3183594.html?mobile=1)，[参考1](https://blog.csdn.net/u013041681/article/details/50279993)

* `f`是一个函数指针，指向一个 `function`，这个`function`的形式参数为`int`，以及一个函数指针`void(*)()`，`function`的返回值为一个函数指针`int(*)(int,int)`
* `next` 是一个函数指针，指向一个不接受任何参数，返回类型为`char * const*`的函数，该函数的返回类型具体含义为`(char (*) (const temp1) ) (*) (p) `=>返回一个指针p，p指向`const指针temp1`，`temp1`指向`char`型数据。`const指针`即指针本身是常量，但是指向的数据不一定是常量。
* `const`修饰符表示常类型，即只读。被`const`修饰符修饰的变量无法写入修改，只可以读取。`const`修饰符只能向后修饰，不能向前修饰，即`const`的作用范围是`const`后面的对象，且`const`后面只能是变量，或者是非指针类型名，在第二种情况下，`const`修饰的是非指针类型名后面的变量。

#### 57. STL空间配置器如何处理内存的？能说一下它的大概实现方案吗？为什么是8bytes的倍数？

[参考](https://blog.csdn.net/lf_2016/article/details/53511648)

* 两级空间配置器

  * 一级空间配置器

    一级空间配置器的底层是调用 `malloc()` 来实现的。

  * 二级空间配置器

    二级空间配置器的内存池+自由链表的形式避免了小块内存带来的碎片化，提高了分配的效率，提高了利用率。SGI的做法是先判断要开辟的大小是不是大于128，如果大于128则就认为是一块大块内存，调用一级空间配置器直接分配。否则的话就通过内存池来分配，假设要分配8个字节大小的空间，那么他就会去内存池中分配多个8个字节大小的内存块，将多余的挂在自由链表上，下一次再需要8个字节时就去自由链表上取就可以了，如果回收这8个字节的话，直接将它挂在自由链表上就可以了。

     为了便于管理，二级空间配置器在分配的时候都是以8的倍数对齐。也就是说二级配置器会将任何小块内存的需求上调到8的倍数处(例如：要7个字节，会给你分配8个字节。要9个字节，会给你16个字节),尽管这样做有内碎片的问题，但是对于我们管理来说却简单了不少。因为这样的话只要维护16个free_list就可以了，free_list这16个结点分别管理大小为8,16,24,32,40,48,56,64,72,80,88,86,96,104,112,120,128字节大小的内存块就行了。

    自由链表的结点类型：

    ```cpp
    union obj{
        union obj* next;
        char data[1];
    }
    ```

* 为什么是 `8B` 的倍数，怎么求需要多少空间

  * 最小内存块也有足够的空间存放下一个指针

  * 方便使用如下的函数进行`ROUND_UP`

    ```cpp
    static size_t ROUND_UP(size_t bytes){
        return ((bytes+_ALIGN-1)&~(_ALIGN-1));
    }
    ```

#### 58. 类的静态成员存储在哪，静态成员函数能访问非静态数据成员吗？静态函数能定义为虚函数吗？为什么？静态函数能定义为常函数吗？为什么？

[参考](https://blog.csdn.net/shltsh/article/details/45999801)

* 类的静态成员函数存放在代码段，类的静态成员对象必须定义，所以类的静态成员对象存放在 `.data` 段
* 类的静态成员函数无法访问非静态数据成员，因为静态成员函数是所有对象共享的，所有不会涉及到 `this` 指针，即无法访问非静态数据成员。
* 静态成员函数不能为虚函数
  * static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
  * 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。对于静态成员函数，它没有this指针，所以无法访问vptr。 这就是为何static函数不能为virtual。
  * **虚函数的调用关系：this -> vptr -> vtable ->virtual function**
* 当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的`const`修饰的成员函数，this指针相当于Test const *, 而对于非const成员函数，this指针相当于 `Test const *`，而`static`成员函数没有`this`指针，所以使用`const`来修饰`static`成员函数没有任何意义。 `volatile` 的道理也是如此。

#### 60. this指针调用成员变量时，堆栈会发生什么变化？ 

[参考](https://www.jianshu.com/p/2de5b739178a)

将相应的参数从右往左压栈，然后将this指针放到寄存器中 

#### 71. 内部排序（各自的时间复杂度，空间复杂度，时间复杂度是否与初始序列有关，各自的稳定性。直接插入排序，希尔排序，简单选择排序，堆排序，冒泡排序，快速排序，归并排序，基数排序，桶排序，折半插入排序?）

[参考](https://www.cnblogs.com/onepixel/articles/7674659.html)

![1](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

* 插入排序

  一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

  - 从第一个元素开始，该元素可以认为已经被排序；
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
  - 如果该元素（已排序）大于新元素，将该元素移到下一位置；
  - 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
  - 将新元素插入到该位置后；
  - 重复步骤2~5。

  ```cpp
  void InsertSort(vector<int>& num){
      int size=num.size(),preindex,current;
      for(int i=1;i<size;++i){
          preindex=i-1;
          current=num[i];
          while(preindex>=0&&num[preindex]>current){
              num[preindex+1]=num[preindex];
              --preindex;
          }
          num[preindex+1]=current;
      }
  }
  ```

* 希尔排序

  1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

  先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

  - 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
  - 按增量序列个数k，对序列进行k 趟排序；
  - 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

  ```cpp
  void ShellSort(vector<int>& num){
      int len=num.size();
      int gap=1;
      while(gap<len/2)
          gap*=2;
      for(;gap>0;gap=gap/2){
          for(int i=gap;i<len;++i){
              int temp=num[i],j=i-gap;
              for(;j>=0;j-=gap){
                  if(num[j]>temp){
                      num[j+gap]=num[j];
                  }
                  else{
                      break;
                  }
              }
              num[j+gap]=temp;
          }
      }
  }
  ```

* 选择排序

  选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

  n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

  - 初始状态：无序区为R[1..n]，有序区为空；
  - 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
  - n-1趟结束，数组有序化了。

  ```cpp
  void SelectSort(vector<int>& num){
      int len=num.size();
      int min,index;
      for(int i=0;i<len;++i){
          min=num[i];
          index=i;
          for(int j=i+1;j<len;++j){
              if(num[j]<min){
                  min=num[j];
                  index=j;
              }
          }
          swap(num[index],num[i]);
      }
  }
  ```

* 堆排序

  堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

  - 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
  - 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
  - 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

  ```cpp
  void AdjustHeap(vector<int>& num,int start,int end){
      if(start>=end)
          return;
      int son=(start<<1)+1;
      while(son<=end){
          if(son+1<=end&&num[son]<num[son+1]) ++son;
          if(num[start]<num[son]){
              swap(num[start],num[son]);
              start=son;
              son=(start<<1)+1;
          }else{
              break;
          }
      }
  }
  void HeapSort(vector<int>& num){
      int len=num.size();
      int last=(len>>1)-1;
      for(int i=last;i>=0;--i){
          AdjustHeap(num,i,len-1);
      }
      for(int i=0;i<len;++i){
          swap(num[0],num[len-1-i]);
          AdjustHeap(num,0,len-2-i);
      }
  }
  ```

* 冒泡排序

  冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

  - 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
  - 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
  - 针对所有的元素重复以上的步骤，除了最后一个；
  - 重复步骤1~3，直到排序完成。

  ```cpp
  void BubbleSort(vector<int>& num){
      int len=num.size()-1;
      for(int last=len;last>=0;--last){
          for(int i=0;i<last;++i){
              if(num[i]>num[i+1])
                  swap(num[i],num[i+1]);
          }
      }
  }
  ```

* 快速排序

  快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

  快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

  - 从数列中挑出一个元素，称为 “基准”（pivot）；
  - 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  - 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

  ```cpp
  int Partation(vector<int>& num, int start, int end){
      int remark=num[end];
      int j=start-1;
      for(int i=start;i<end;++i){
          if(num[i]<remark){
              ++j;
              if(i!=j)
                  swap(num[i],num[j]);
          }
      }
      swap(num[j+1],num[end]);
      return j+1;
  }
  
  void QuickSortCore(vector<int>& num, int start, int end){
      if(start>=end)
          return;
      auto index=Partation(num,start,end);
      QuickSortCore(num,start,index-1);
      QuickSortCore(num,index+1,end);
      return;
  }
  
  void QuickSort(vector<int>& num){
      QuickSortCore(num,0,num.size()-1);
  }
  ```

* 归并排序

  归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

  - 把长度为n的输入序列分成两个长度为n/2的子序列；
  - 对这两个子序列分别采用归并排序；
  - 将两个排序好的子序列合并成一个最终的排序序列。 

  1. 非原地归并

  ```cpp
  void merge_core(vector<int>& num, vector<int>& res, int start, int end){
      if(start>=end)
          return;
      int mid=((end-start)>>1)+start;
      merge_core(num,res, start,mid);
      merge_core(num,res,mid+1,end);
      int l=start,r=mid+1,k=start;
      while(l<=mid&&r<=end){
          if(num[l]<num[r]){
              res[k++]=num[l++];
          }else{
              res[k++]=num[r++];
          }
      }
      if(l==mid+1){
          while(k<=end)
              res[k++]=num[r++];
      }else{
          while(k<=end)
              res[k++]=num[l++];
      }
      for(int i=start;i<=end;++i){
          num[i]=res[i];
      }
  }
  
  void MergeSort(vector<int>& num){
      vector<int> res(num.size());
      merge_core(num,res,0,num.size()-1);
  }
  ```

  2. 原地归并

* 计数排序

* 桶排序

* 基数排序

#### STL下 `sort()` 的内部实现，`stable_sort()` 内部实现

* `sort()`
  * 优化之后的快排+插入排序，由于快排的原因，它是不稳定的。
* `stable_sort()` 
  * 归并排序+插入排序，由于归并以及插入排序都是稳定的，所以这个排序算法是稳定的。

#### 72. 外部排序算法

#### `top K` 问题

[参考](https://www.cnblogs.com/en-heng/p/6336625.html)

#### 各种二分查找

[参考](https://www.zhihu.com/question/36132386)

#### 类继承的情况下，构造调用顺序和析构调用顺序？

* 构造函数
  * 按照继承顺序，依次调用基类的构造函数，最后调用自身的构造函数。
  * 当一个类初始化自身的成员时，是按照在类中声明的顺序进行的。
* 析构函数
  * 与构造函数的调用顺序相反。

#### 如何禁止自动生成拷贝构造函数？  

将拷贝构造函数设为 `protected` 或者 `private`，或者利用`delete`关键字

```cpp
class A{
public:
    A(){}
    ~A(){}
protected:
    A(const A&){}
}
```

```cpp
class A{
public:
    A(){}
    ~A(){}
protected:
    A(const A&)=delete;
}
```

#### vector实现原理，vector迭代器失效什么时候发生，vector初始时容量，vector容积从1开始,push_back N个元素的时间复杂度，如何实现vector 在扩容的时候不进行新的空间申请，即不想有扩容操作，该如何设计？ --- 从operator new和placement new方面来讲。

#### 虚函数指针是否肯定占据对象前几个字节，在32，64位系统中多少字节？

#### 74. 图（深度广度优先遍历、单源最短路径、最小生成树）， 已知一个有向无环图，确定一个拓扑序列，用代码实现

#### 75. 递归需要注意什么问题？伪递归，实现机制？ 

#### 76. 分治与递归：逆序对数，大数相加，大数相乘

#### 77. 字符串匹配算法：KMP算法，BM算法，Sunday算法

#### 78. 用模板实现一个栈(内部使用动态申请的数组作为存储结构)

#### 82. 设计一个函数，如果需要修改形参，应该怎么做（引用或者指针）

#### 85. ++i和i++的区别

#### 86. struct和union的区别，struct如果里面存了double，int，short请问这个struct有几个字节，怎么存储的 

#### 90. 必须在构造函数初始化式里进行初始化的数据成员有哪些

#### 98. 语句 char *p = new char[32]; 如果用delete p，会发生什么？如果用malloc和free怎么申请和释放32个字节的buffer？如果用free(p) 可以吗？ 为什么delete []就可以删除整个数组。 

#### 100. 一个.c文件不include .h文件，却调用了 .h文件定义的函数，能否正确编译？

#### 102. deque模型

#### 104. 函数内 static 与函数外 static

#### 105. 实现STL中的push_back

#### 106. 红黑树为何优于平衡二叉树(AVL)？

#### 107. 开链法的缺点

#### 108. 哈希表的冲突处理方法

#### 114. 成员函数末尾带const表示什么，如何在const成员函数中改变数据成员。

#### 115. 函数重载的实现，与返回值、函数名、类型数量、类型有关？如果形参为const int与int能重载么。

#### 116. 虚函数表有多少张。

#### 117. 动态多态如何实现——虚函数表指针。

#### 119. 字符数组中A、B两字串拼接在一起，不使用辅存如何最快交换为B、A

#### 120. Html标签提取，保存在K-V存储器中，正则和算法

#### 123. STL线程安全与不安全

#### 124. HashMap和HashTable区别

#### 129. 如何实现一个优先级队列 

#### 130. 两道编程：二叉树镜像、集合的所有子集

#### 131. 先递增后递减的数组中找最值

#### 132. 写一下将一个整型的二进制后三位清零？

#### 133. 用一个父类的指针，怎么调用子类的虚函数的？他们的调用流程是什么？

#### 134. printf("%s%d", s, d)的压栈情况？突出说明要压入下一条指令执行的地址，保护现场

#### 138. 求某点到边缘的最短路径，起始点为S，墙为X，路为空格

#### 139. 链表的奇数号节点和偶数号节点调换位置

#### 140. 实现一个字典，类似于C++ 中的map，及优化其中的key值比较函数

#### 141. 1台源机器有100g数据要更新到100台目标机器上，假设带宽是1000m／s，目标机器更新完100g数据可以作为新的源机器。问你怎么采用策略使得时间最短；假如把100g数据分片，为1g的100片，1g作为最小的传输单位，即这一片接收完就可以发给别的主机，问策略又是什么

#### 143. int (*p)[10 ] 和 int *p[10 ] 区别

#### 144. 有序数组重排  o(n) 时间复杂度 o(1) 空间

#### 145. 求完全二叉树最后一个节点

#### 146. 全排序算法

#### 147. n边形分割成n-2个三角形，求分割的方法有多少

#### 148. 判断是否是二叉搜索树

#### 149. `child*p=(child*)new base; p->f();` 输出什么？

#### 150. static，在C和C++的区别  

#### 151. 类的成员变量初始化，构造函数里不能初始化什么，引用，类里可不可以定义

#### 152. 父类指针指向子类对象的写法

#### 153. 写虚函数的覆盖

#### 154. 二叉树的深度优先、广度优先遍历

#### 155. 一条直线上多个点碰撞，求最后剩下的点

#### 157. swap知道吗，交换空间么，swap有哪些设置的参数， 我就知道个设置大小，一般为2倍 

#### 158. 定义一个char *p，问sizeof(p)多大，char *p=new char[10]，sizeof(p)多大？

#### 159. 定义一个类，类中有一个fun函数，定义一个*p=null，的空指针，p->fun()会出现什么结果？为什么？如果fun是虚函数呢？ 

#### 160. 写一下n!的实现？如果有一百万次询问怎么高效解决？

#### 162. 定义一个const int i = 1;怎么保证i这个变量只可读不可写？你觉得是怎么实现的呢？ 

#### 163. 单继承中虚函数是怎么实现的？

#### 164. C++11的一些特性，C++14呢，C++17呢？lamdba匿名函数了解吗？为什么要有lamdba匿名函数？有什么好处呢？ 

#### 165. 重载和多态有什么区别？

#### 167. class里如何给引用类型成员初始化

#### 168. C malloc出来的内存 可以调用delete吗？为什么

#### 169. 生产者消费者模型的抽象实现  

#### 171. 设计一个内存分配类---参考STL中空间配置器 

#### 172. 现有一个程序需要申请的地址是要求起始地址必须是16的倍数，如何设计----将申请大小上调至16的倍数，那么最多会浪费15byte空间，真正存储从16byte倍数上开始利用。 

#### 174. Vistual Studio 怎么调试，如何设置条件断点 

#### 175. C++如何处理异常，异常向上抛出抛到最上层是什么情况？ 

#### 176. hashmap、hasptable、concurrenthashmap的区别，concurrenthashmap如何实现高并发？ 

#### 185. 指针常量和常量指针

#### 186. string 的构造次数

#### 187. 如何控制数据流？

#### 190. 模版和类封装各自在什么不同的情况使用，各有什么优缺点？

#### 192. C++11的auto和lambda。 

#### 193. 类中哪些函数不能为虚函数？static成员函数如果想实现虚函数的功能，怎么实现？

#### 194. 介绍下平衡二叉树？

#### 195. 堆的数据结构？提示了最大堆和最小堆。

#### 196. 怎样实现一个最小类或者结构体。除了不让内存对齐，还有其他方式吗？

#### 197. 函数的调用怎么实现的，传参呢？

#### 198. 对于默认处理的结构体，能用memcmp来进行比较吗？为什么？如果不能，该如何比较？ 

#### 199. 手写一个有可变参数的函数？ 

#### 200. varchar和char的使用场景。

#### 201. 接口和抽象类区别

#### 205. OOP特性，通过哪些机制实现的

#### 206. 重写和重载区别

#### 207. 静态类静态方法

#### 208. 根据某个需求设计一个类（主要考虑类之间的继承关系和属性的权限设置）

#### 210. 栈上对象与堆上对象比较 

#### UML知道吗？能用UML绘制常用的设计模式吗？

####  出现异常时，try，catch，throw，finally的用法？C++如何处理多个异常的？

#### 介绍一下C++ traits的原理以及作用？

#### 变量的存储方式有哪些？

## 常用 Linux 指令以及库函数

#### netstat

#### tcpdump

#### ipcs

#### ipcrm

#### ps

#### top

#### free

#### awk, sed, grep

#### find

#### df

#### fdisk

#### head, tail

#### `fork()` 与 `vfork()` 区别 

#### `exit()` 与 `_exit()` 区别 

## 操作系统

#### Linux 下进程状态

#### 同一个进程的线程之间共享什么，独有什么。

#### 进程间通信

#### 共享内存的实现原理？ 

#### 协程，线程，进程

#### 僵尸进程，孤儿进程，守护进程

#### **列出常见的信号，系统如何将一个信号通知到进程、信号怎么处理**，信号的生命周期？信号的产生方式？信号处理方式？  

#### Linux内存管理机制、Linux的内存分布

#### 死锁产生的条件，如何预防。银行家算法

#### 操作系统加载流程？ 

#### 介绍一下内核态和用户态的区别

#### 静态库与动态库，静态链接与动态链接，硬链接与软链接的区别

#### 创建进程的步骤？进程切换发生的原因？处理进程切换的步骤？  



## 计算机网络

#### 访问一个URL的过程都发生了什么。DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程。

#### IO的五种模型

#### IO多路复用中的 `select()`, `poll()`, `epoll()`

#### socket什么情况下可读，可写？如果select返回可读，结果只读到0字节，什么情况？connect会阻塞，怎么解决？

#### 访问一个URL的过程都发生了什么。

#### TCP 和 UDP 的区别，TCP 报头，UDP 报头。

#### TCP的三次握手，四次挥手，重传机制，流量控制，拥塞控制，保活机制，滑动窗口，Nagle算法，延迟 ACK，粘包问题，确认重传机制，慢开始，拥塞避免，快重传，停止等待，超时重传

#### TCP 两次握手，三次握手分别会造成什么问题

#### TCP 四次挥手的 TIME_WAIT 状态要持续多久，为什么

#### HTTP1, HTTP2, HTTPS, HTTP协议头

## 数据库

#### 数据库事物的四大特新、事务隔离级别

#### B树，B+树，B*树，innodb，myisam的区别

#### 关系型数据库与非关系型数据库

#### 索引是什么，多加索引一定会好吗

## 经典算法题

#### 10亿个11位的号码中找给定号码是否存在

#### 一个求数字中1的个数，写完O（n）的要优化到O（1），优化到O（1）想到hash表

#### aoi算法

#### 一个线段上任意选取两点，求这三小段围成三角形的概率

#### 如何在一个队列中记录当队列的最大值，追问，`pop`、`push`、`getmax` 这三个方法都是O(n*lg(n))的时间复杂度

#### 在王者荣耀中如何统计全服中所有玩家阿轲这个英雄的胜场排名？

#### 统计逆序对个数，求时间复杂度

#### 如何将一个序列均等分为两部分，使得这两部分之和尽量小

#### 如何监测网络字节序大端小端

#### 100万有序数据，是否存在两数之和等于给定值

#### 实现sqrt()函数，不能使用库函数

#### 问算法题，一个大文件中有很多字符串，如何统计出现次数最多的字符串

#### 判断链表是否有环，求出环的入口

#### 链表是否相交，两个链表交叉求交叉点

#### 反转链表

#### 求最长递增子序列

#### 判断一个树是不是avl树（递归非递归）

#### 求海量数据下第k大的数

#### 怎么统计char二进制中1的个数

#### 在一个有序数组中，求中位数，如何设计这个函数，形参和返回类型？

#### 编程之美的水王问题。找到数组中出现次数超过等于一半的那个ID

#### 有一个数组，每个数字代表挡板的高度，求最大储水量，o(n)复杂度

#### 已知一个二叉树，每个节点有一个数值，用路径值表示该路径上所有节点值的和，求全局最大路径值

#### 设计T9输入法的数据结构，Trie树+HashMap

#### 现在多个活动，有多个开始和结束时间，计算出其中某个时间有最多活动的个数， 当时脑袋发热

#### 有两个排序数组，数组长度都为n，二分法求第n、n+1大的数

#### 已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器， 使得它构造0和1的概率均为1/2

#### 一个链表，求倒数第M、N个元素

#### 数组中乱序+、-、0三种字符，把+置左，-置右

#### 链表插入节点

#### 使用链表进行大数字的加减

#### 实现一个双向循环链表

#### 实现一个 hash表

#### 手写strcpy, strncpy, strcmp, strcat, memcpy, memmove, memset, memcmp函数

#### 单链表去重

#### 单链表删除结点(仅给出删除结点)

#### 单例模式？手写线程安全的单例模式？懒汉式？饿汉式？

#### AVL树，红黑树的插入与删除

#### 翻转二叉树

#### 二叉树前中后序遍历

#### 实现后序优先遍历的非递归算法

#### 二叉树的广度优先遍历，深度优先遍历，求深度，求宽度

#### 一个停车场，一个入口，三个出口，设计停车管理程序

#### 给一个1~n的无序数组，求最少次数让这个数组变为有序。

## 设计模式

#### 设计模式是否了解，如工厂模式、装配者、适配器。

#### 设计模式（工厂模式、策略模式、单例模式、装饰模式比较常见）

## 投递进度
